const fs = require('fs-extra');
const { S3, PutObjectCommand, GetObjectCommand, ListObjectsCommand, CopyObjectCommand, DeleteObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require("@aws-sdk/s3-request-presigner");
const mime = require('mime-types');
const path = require('path');

/**
 * Builds an S3 configuration object with credentials and endpoint settings.
 *
 * @param {Object} options - Configuration options object
 * @param {string} options.accessKeyId - AWS access key ID (required)
 * @param {string} options.secretAccessKey - AWS secret access key (required)
 * @param {string} [options.region='us-east-1'] - AWS region
 * @param {string} [options.provider='aws'] - Cloud provider type
 * @param {string} [options.endpoint=''] - Custom endpoint URL for non-AWS providers
 * @param {boolean} [options.forcePathStyle=false] - Force path-style URLs instead of virtual-hosted-style
 * @param {Object} ctx - Context object (the "this" JS context) with parsing utilities
 * @param {Function} ctx.parseRequired - Parses required configuration values
 * @param {Function} ctx.parseOptional - Parses optional configuration values with defaults
 *
 * @returns {Object} Configuration object containing:
 * @returns {Object} .config - S3 client configuration with credentials and endpoint
 * @returns {string} .region - AWS region
 * @returns {string} .provider - Cloud provider type
 * @returns {boolean} .forcePathStyle - Force path-style URL setting
 *
 * @throws {Error} If required fields are missing.
 */
function buildS3Config(options, ctx) {
    const accessKeyId = ctx.parseRequired(options.accessKeyId, 'string', 'AccessKeyId is required.');
    const secretAccessKey = ctx.parseRequired(options.secretAccessKey, 'string', 'SecretAccessKey is required.');
    const region = ctx.parseOptional(options.region, 'string', 'us-east-1');
    const provider = ctx.parseOptional(options.provider, 'string', 'aws');
    const endpointOption = ctx.parseOptional(options.endpoint, 'string', '');
    const forcePathStyle = ctx.parseOptional(options.forcePathStyle, 'boolean', false);

    const config = {
        region,
        credentials: { accessKeyId, secretAccessKey },
        forcePathStyle,
        endpoint: `https://s3.${region}.amazonaws.com`
    };

    if (provider === "custom" && endpointOption) {
        config.endpoint = endpointOption;
    }

    return { config, region, provider, forcePathStyle };
}

/**
 * Creates and returns a configured S3 client instance
 * using the settings generated by buildS3Config().
 * 
 * @param {*} options 
 * @param {*} ctx 
 * 
 * @returns {S3} Configured AWS S3 client instance
 */
function getS3Client(options, ctx) {
  const { config } = buildS3Config(options, ctx);
  return new S3(config);
}

/**
 * Generates the public URL for an S3 object.
 * - Uses path-style URL if forcePathStyle is true or provider is custom.
 * - Otherwise uses AWS virtual-hosted-style URL.
 * - Encodes the object key to ensure a valid URL.
 * 
 * @param {string} endpoint - Base S3 endpoint
 * @param {string} bucket - Bucket name
 * @param {string} key - Object key
 * @param {string} region - AWS region
 * @param {string} provider - Provider type ('aws' | 'custom')
 * @param {boolean} forcePathStyle - Whether to use path-style URL
 *
 * @returns {string} Generated file URL
 *
 * @example
 * // Virtual hosted style
 * https://my-bucket.s3.us-east-1.amazonaws.com/file.pdf
 *
 * @example
 * // Path style
 * https://s3.us-east-1.amazonaws.com/my-bucket/file.pdf
 */
function buildFileUrl({ endpoint, bucket, key, region, provider, forcePathStyle }) {
  if (forcePathStyle || provider === "custom") {
      return `${endpoint.replace(/\/$/, '')}/${bucket}/${encodeURIComponent(key)}`;
  }
  return `https://${bucket}.s3.${region}.amazonaws.com/${encodeURIComponent(key)}`;
}

exports.s3_signed_upload = async function (options) {
  const Bucket = this.parseRequired(options.bucket, 'string', 'Bucket is required.');
  const Key = this.parseRequired(options.key, 'string', 'Key is required.');
  const ContentType = this.parseOptional(options.contentType, 'string', mime.lookup(Key) || 'application/octet-stream');
  const expiresIn = this.parseOptional(options.expires, 'number', 300);
  const ACL = this.parseOptional(options.acl, 'string',undefined);

  const s3 = getS3Client(options, this);
  const command = new PutObjectCommand({ Bucket, Key, ContentType, ACL });

  return getSignedUrl(s3, command, { expiresIn });
};

exports.s3_signed_download = async function (options) {
  const Bucket = this.parseRequired(options.bucket, 'string', 'Bucket is required.');
  const Key = this.parseRequired(options.key, 'string', 'Key is required.');
  const expiresIn = this.parseOptional(options.expires, 'number', 300);

  const s3 = getS3Client(options, this);
  const command = new GetObjectCommand({ Bucket, Key });

  return getSignedUrl(s3, command, { expiresIn });
};

exports.s3_put_object = async function (options) {
  const File = this.parseRequired(options.file, 'string');
  const Bucket = this.parseRequired(options.bucket, 'string', 'Bucket is required.');
  const Key = this.parseRequired(options.key, 'string', 'Key is required.');
  const ContentType = this.parseOptional(options.contentType, 'string', mime.lookup(Key) || 'application/octet-stream');
  const ACL = this.parseOptional(options.acl, 'string');
  const ContentDisposition = this.parseOptional(options.contentDisposition, 'string');
  const useFilePath = this.parseOptional(options.useFilePath, 'boolean', false);

  const { config, region, provider, forcePathStyle } = buildS3Config(options, this);
  const s3 = new S3(config);

  let filePath = useFilePath
      ? path.join(process.cwd(), File)
      : this.req.files[File].tempFilePath;

  const Body = fs.createReadStream(filePath);

  const command = new PutObjectCommand({
      Bucket,
      Key,
      ContentType,
      ACL,
      ContentDisposition,
      Body
  });

  const result = await s3.send(command);

  return {
      ...result,
      url: buildFileUrl({
          endpoint: config.endpoint,
          bucket: Bucket,
          key: Key,
          region,
          provider,
          forcePathStyle
      }),
      bucket: Bucket,
      key: Key
  };
};

exports.s3_put_objects = async function (options) {
  const Files = this.parseRequired(options.files, 'array', 'Files input array is required.');
  const Bucket = this.parseRequired(options.bucket, 'string', 'Bucket is required.');
  const baseKey = this.parseOptional(options.baseKey, 'string', '');
  const keyPattern = this.parseOptional(options.keyPattern, 'string', 'filename');
  const ACL = this.parseOptional(options.acl, 'string', undefined);
  const useFilePath = this.parseOptional(options.useFilePath, 'boolean', false);

  // reuse shared config builder
  const { config, region, provider, forcePathStyle } = buildS3Config(options, this);
  const s3 = new S3(config);

  try {
    let counter = 0;
    const timestamp = Date.now();

    const uploadResults = await Promise.all(
      Files.map(async (fileInfo) => {
        const filename = path.basename(fileInfo.file);

        // ---------- key generation ----------
        let Key;
        switch (keyPattern) {
          case 'increment':
            counter++;
            Key = `${baseKey}${counter}`;
            break;

          case 'timestamp':
            Key = `${baseKey}${timestamp}`;
            break;

          case 'filename':
          default:
            Key = `${baseKey}${filename}`;
        }

        // normalize key
        Key = Key.replace(/\/+/g, '/').replace(/^\//, '');

        // ---------- file source ----------
        const filePath = useFilePath
          ? path.join(process.cwd(), fileInfo.file)
          : this.req.files[fileInfo.file].tempFilePath;

        const Body = fs.createReadStream(filePath);

        const ContentType =
          fileInfo.contentType ||
          mime.lookup(Key) ||
          'application/octet-stream';

        const ContentDisposition = fileInfo.contentDisposition;

        // ---------- upload ----------
        const command = new PutObjectCommand({
          Bucket,
          Key,
          Body,
          ContentType,
          ACL,
          ContentDisposition
        });

        const result = await s3.send(command);

        // ---------- url ----------
        const url = buildFileUrl({
          endpoint: config.endpoint,
          bucket: Bucket,
          key: Key,
          region,
          provider,
          forcePathStyle
        });

        return {
          ...result,
          url,
          bucket: Bucket,
          key: Key,
          originalFile: fileInfo.file
        };
      })
    );

    return {
      success: true,
      results: uploadResults
    };

  } catch (error) {
    throw new Error(`Failed to upload files to S3: ${error.message}`);
  }
};

/**
 * Lists object from an S3 bucket.
 * @param {Object} options - Configuration options
 *
 * @returns {Promise<Array<{ key: string }>|Object>}
 * 
 * Response Structure:
 * 
 * Success Response:
 * {
 *   success: boolean,   // true if operation succeeds, false if it fails
 *   files?: string[],     // Present only when success = true
 * }
 * 
 * Error Response:
 * {
 *  success: boolean,   // true if operation succeeds, false if it fails
 *  message?: string,   // Present only when success = false
 *   err?: {             // Populated only when success = false
 *     message: string,
 *     code: string,
 *     requestId?: string
 *    }
 *  }
 *
 * @throws {Error} If required fields are missing.
 */
exports.s3_list_files = async function (options) {
  const Bucket = this.parseRequired(options.bucket, 'string', 'Bucket is required.');
  const Prefix = this.parseOptional(options.prefix, 'string', 'Prefix is required');

  try {
    const { config, region, provider, forcePathStyle } = buildS3Config(options, this);
    const s3 = new S3(config);
    const result = await s3.send(
      new ListObjectsCommand({ Bucket, Prefix })
    );
    return {
      success: true,
      files: result.Contents?.map(({ Key }) => Key) ?? []
    };

  } catch (err) {
    return {
      success: false,
      message: 'S3 list failed.',
      err: {
        message: err.message,
        code: err.name || err.code,
        requestId: err.$metadata?.requestId 
      }
    };
  }
};

/**
 * Copies file from source bucket to the destination bucket
 * @param {Object} options - Configuration options
 *
 * @returns {Object}
 * 
 * Success Response:
 * {
 *   success: boolean,   // true if operation succeeds, false if it fails
 * }
 *
 * Error Response:
 * {
 *  success: boolean,   // true if operation succeeds, false if it fails
 *  message?: string,   // Present only when success = false
 *   err?: {             // Populated only when success = false
 *     message: string,
 *     code: string,
 *     requestId?: string
 *   }
 * }
 *
 * @throws {Error} If required fields are missing.
 */
exports.s3_copy_object = async function (options) {
  const SrcBucket = this.parseRequired(options.srcBucket, 'string', 'Source Bucket is required.');
  const SrcKey = this.parseRequired(options.srcKey, 'string', 'Source Key is required.');
  const DstBucket = this.parseRequired(options.dstBucket, 'string', 'Destination Bucket is required.');
  const DstKey = this.parseRequired(options.dstKey, 'string', 'Destination Key is required.');

  if (SrcKey === DstKey) {
    return {
      success: false,
      message: 'Source and Destination keys must be different.'
    };
  }
  const s3 = getS3Client(options, this);

  try {
    await s3.send(new CopyObjectCommand({
      Bucket: DstBucket,
      Key: DstKey,
      CopySource: `${SrcBucket}/${SrcKey}`
    }));

    return {
      success: true
    };

  } catch (err) {
    return {
      success: false,
      message: 'S3 copy failed.',
      err: {
        message: err.message,
        code: err.name || err.code,
        requestId: err.$metadata?.requestId 
      }
    };
  }
}; 

/**
 * Deletes file from the provided bucket
 * @param {Object} options - Configuration options
 *
 * @returns {Object}
 * 
 * Success Response:
 * {
 *   success: boolean,   // true if operation succeeds, false if it fails
 * }
 *
 * Error Response:
 * {
 *  success: boolean,   // true if operation succeeds, false if it fails
 *  message?: string,   // Present only when success = false
 *   err?: {             // Populated only when success = false
 *     message: string,
 *     code: string,
 *     requestId?: string
 *   }
 * }
 *
 * @throws {Error} If required fields are missing.
 */
exports.s3_delete_file = async function (options) {
  const Bucket = this.parseRequired(options.bucket, 'string', 'Bucket is required.');
  const Key = this.parseRequired(options.key, 'string', 'Key is required.');
  const s3 = getS3Client(options, this);
  try {
    await s3.send(new DeleteObjectCommand({ Bucket, Key }));
    
    return {
      success: true
    };

  } catch (err) {
    return {
      success: false,
      message: 'S3 delete failed.',
      err: {
        message: err.message,
        code: err.name || err.code,
        requestId: err.$metadata?.requestId 
      }
    };
  }
};